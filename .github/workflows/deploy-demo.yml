name: Deploy Demo Environment

on:
  workflow_dispatch:  # Allow manual triggering
  workflow_run:
    workflows: ["Publish Container Images"]
    types:
      - completed
    branches:
      - main

jobs:
  check-if-should-deploy:
    # Skip artifact check for manual dispatch
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
    steps:
      - name: Download build status artifact
        uses: actions/download-artifact@v4
        with:
          name: build-status
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
        continue-on-error: true
        
      - name: Check if develop image was built
        id: check
        run: |
          # For manual dispatch, always deploy
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Manual dispatch, proceeding with deployment"
          elif [ -f build-status.txt ] && grep -q "BUILT_DEVELOP_IMAGE=true" build-status.txt; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ New develop image was built, proceeding with deployment"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è No new develop image was built, skipping deployment"
          fi

  deploy:
    needs: check-if-should-deploy
    if: ${{ needs.check-if-should-deploy.outputs.should-deploy == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Log deployment start
        run: |
          echo "üöÄ Starting deployment to demo server..."
          echo "Container publish succeeded: ${{ github.event.workflow_run.conclusion == 'success' }}"

      - name: Deploy to demo server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEMO_HOST }}
          username: ${{ secrets.DEMO_USERNAME }}
          key: ${{ secrets.DEMO_SSH_KEY }}
          script: |
            set -e  # Exit immediately if any command fails
            cd ~

            # Remove existing repository to ensure clean state
            if [ -d "kasho" ]; then
              echo "Removing existing kasho directory..."
              rm -rf kasho
            fi

            # Clone fresh copy of the repository (using HTTPS for public repo)
            echo "Cloning fresh repository..."
            git clone https://github.com/${{ github.repository }}.git kasho
            cd kasho
            
            # Install Task if not present
            if ! command -v task &> /dev/null; then
              echo "Installing Task..."
              curl -sL https://taskfile.dev/install.sh | sh
              # Use user's local bin instead of system-wide (no sudo needed)
              mkdir -p ~/.local/bin
              mv ./bin/task ~/.local/bin/task
              export PATH="$HOME/.local/bin:$PATH"
            fi
            
            # Log in to Docker Hub
            echo "${{ secrets.DOCKER_HUB_TOKEN }}" | docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} --password-stdin
            
            # Pull the develop image
            docker pull kashoio/kasho:develop
            
            cd environments/pg-demo
            
            # Create .env file from secrets
            cat > .env << EOL
            # User and group IDs for file permissions
            UID=$(id -u)
            GID=$(id -g)
            
            # Redis connection for pg-change-stream
            KV_URL=${{ secrets.KV_URL }}
            
            # Change stream service for pg-translicator
            CHANGE_STREAM_SERVICE_ADDR=${{ secrets.CHANGE_STREAM_SERVICE_ADDR }}

            # Primary database URL for pg-change-stream
            PRIMARY_DATABASE_URL=${{ secrets.PRIMARY_DATABASE_URL }}
            
            # Replica database URL for pg-translicator
            REPLICA_DATABASE_URL=${{ secrets.REPLICA_DATABASE_URL }}
            
            # Database configuration for docker-compose PostgreSQL containers
            PRIMARY_DATABASE_SU_USER=${{ secrets.PRIMARY_DATABASE_SU_USER }}
            PRIMARY_DATABASE_SU_PASSWORD=${{ secrets.PRIMARY_DATABASE_SU_PASSWORD }}
            PRIMARY_DATABASE_DB=${{ secrets.PRIMARY_DATABASE_DB }}
            REPLICA_DATABASE_SU_USER=${{ secrets.REPLICA_DATABASE_SU_USER }}
            REPLICA_DATABASE_SU_PASSWORD=${{ secrets.REPLICA_DATABASE_SU_PASSWORD }}
            REPLICA_DATABASE_DB=${{ secrets.REPLICA_DATABASE_DB }}
            EOL

            docker compose down -v
            docker compose up -d
            
            # Wait for services to start
            sleep 10
            
            # Verify critical services are running
            echo "üîç Checking service status..."
            docker compose ps --format "table {{.Name}}\t{{.Status}}"
            
            # Check pg-change-stream service
            if ! docker compose ps pg-change-stream | grep -q "Up"; then
              echo "‚ùå pg-change-stream failed to start"
              echo "üìã pg-change-stream logs:"
              docker compose logs --tail=50 pg-change-stream
              exit 1
            else
              echo "‚úÖ pg-change-stream is running"
            fi
            
            # Check pg-translicator service
            if ! docker compose ps pg-translicator | grep -q "Up"; then
              echo "‚ùå pg-translicator failed to start"
              echo "üìã pg-translicator logs:"
              docker compose logs --tail=50 pg-translicator
              exit 1
            else
              echo "‚úÖ pg-translicator is running"
            fi
            
            # Check database services
            if ! docker compose ps postgres-primary | grep -q "Up"; then
              echo "‚ùå postgres-primary failed to start"
              docker compose logs --tail=30 postgres-primary
              exit 1
            else
              echo "‚úÖ postgres-primary is running"
            fi
            
            if ! docker compose ps postgres-replica | grep -q "Up"; then
              echo "‚ùå postgres-replica failed to start"
              docker compose logs --tail=30 postgres-replica
              exit 1
            else
              echo "‚úÖ postgres-replica is running"
            fi
            
            # Check redis service
            if ! docker compose ps redis | grep -q "Up"; then
              echo "‚ùå redis failed to start"
              docker compose logs --tail=30 redis
              exit 1
            else
              echo "‚úÖ redis is running"
            fi
            
            echo "üéâ All services are running successfully"
            
            # Wait for pg-change-stream to be ready
            echo "‚è≥ Waiting for pg-change-stream to be ready..."
            for i in {1..30}; do
              if docker exec demo-pg-change-stream-1 nc -z localhost 50051 2>/dev/null; then
                echo "‚úÖ pg-change-stream is ready"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "‚ùå pg-change-stream failed to become ready"
                exit 1
              fi
              sleep 2
            done
            
            # Run bootstrap process
            echo "üöÄ Starting Kasho bootstrap process..."
            cd ../..
            
            # Check if bootstrap script exists
            if [ ! -f "./scripts/runtime/bootstrap-kasho.sh" ]; then
              echo "‚ùå bootstrap-kasho.sh not found"
              exit 1
            fi
            
            # Run bootstrap process in a dedicated container
            # Note: We use internal Docker service names (postgres-primary, redis, pg-change-stream)
            # because the container is on the demo_default network and cannot reach
            # the host's external IP to loop back to other containers.
            docker run --rm \
              --network demo_default \
              -e PRIMARY_DATABASE_URL="postgresql://${{ secrets.PRIMARY_DATABASE_SU_USER }}:${{ secrets.PRIMARY_DATABASE_SU_PASSWORD }}@postgres-primary:5432/${{ secrets.PRIMARY_DATABASE_DB }}?sslmode=disable" \
              -e KV_URL="redis://redis:6379" \
              -e CHANGE_STREAM_SERVICE_ADDR="pg-change-stream:50051" \
              -e REPLICATION_SLOT_NAME="kasho_slot" \
              -e WAIT_FOR_BOOTSTRAP="true" \
              kashoio/kasho:develop \
              /app/scripts/bootstrap-kasho.sh
            
            echo "‚úÖ Bootstrap process completed successfully"

  deployment-status:
    runs-on: ubuntu-latest
    needs: [check-if-should-deploy, deploy]
    if: always()
    steps:
      - name: Deployment Status
        run: |
          echo "üìä Deployment Status Report"
          echo "=========================="
          echo "Container publish succeeded: ${{ github.event.workflow_run.conclusion == 'success' }}"
          echo "New develop image built: ${{ needs.check-if-should-deploy.outputs.should-deploy == 'true' }}"
          echo "Deployment job status: ${{ needs.deploy.result }}"
          
          if [[ "${{ github.event.workflow_run.conclusion }}" != "success" ]]; then
            echo "‚ùå Deployment skipped: Container publish workflow failed"
          elif [[ "${{ needs.check-if-should-deploy.outputs.should-deploy }}" != "true" ]]; then
            echo "‚è≠Ô∏è Deployment skipped: No new develop image was built"
          elif [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "‚úÖ Deployment completed successfully"
          else
            echo "‚ùå Deployment failed"
          fi