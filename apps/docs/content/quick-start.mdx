# Quick Start

This guide will help you understand Kasho's architecture and get it running in your environment. While we use Docker Compose as an example, the concepts apply to any production orchestration system like Kubernetes.

## Production Deployment Overview

Kasho consists of three required containers that work together:

1. **Redis** - Used for distributed state management and caching
2. **pg-change-stream** - Captures changes from your source PostgreSQL database
3. **pg-translicator** - Applies transformations and writes to your target database

<div className="alert alert-info mb-6">
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" className="stroke-current shrink-0 w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
  <div>
    <div className="font-semibold">Production Environments</div>
    <div>Most production deployments use Kubernetes, ECS, or similar orchestration systems. The Docker Compose example below illustrates how the containers interact and can be adapted to your specific environment.</div>
  </div>
</div>

### Container Images

All Kasho components are packaged in a single Docker image:
- Image: `kasho:latest` (or your specific version tag)
- Commands: `./pg-change-stream` and `./pg-translicator`

## Prerequisites

<div className="alert alert-warning mb-6">
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" className="stroke-current shrink-0 w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
  <div>
    <div className="font-semibold">Important: Single Translicator Only</div>
    <div>Currently, only a single `pg-translicator` instance is supported. Multiple translicators would process the same changes multiple times.</div>
  </div>
</div>

Before you begin, ensure you have:
- PostgreSQL 15+ databases (source and target)
- Databases configured with `wal_level = logical`
- A Redis instance (or Redis-compatible service)
- Container orchestration system (Kubernetes, ECS, Docker, etc.)
- Access to pull the Kasho container image

## Docker Compose Example

<div className="alert alert-info mb-6">
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" className="stroke-current shrink-0 w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
  <div>
    <div className="font-semibold">Example Configuration</div>
    <div>The following Docker Compose configuration demonstrates how Kasho's containers interact. Adapt this to your production orchestration system (Kubernetes manifests, ECS task definitions, etc.).</div>
  </div>
</div>

### Step 1: Example Directory Structure

For this example, create a directory structure:

```bash
mkdir kasho-example
cd kasho-example
```

### Step 2: Example Docker Compose Configuration

Create a `docker-compose.yml` file:

```yaml
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data

  pg-change-stream:
    image: kasho:latest
    command: ./pg-change-stream
    environment:
      KV_URL: redis://redis:6379
      PRIMARY_DATABASE_URL: ${PRIMARY_DATABASE_URL}
      LICENSING_SERVICE_ADDR: ${LICENSING_SERVICE_ADDR}
    ports:
      - "50051:50051"
    depends_on:
      - redis

  pg-translicator:
    image: kasho:latest
    command: ./pg-translicator
    environment:
      CHANGE_STREAM_SERVICE_ADDR: pg-change-stream:50051
      REPLICA_DATABASE_URL: ${REPLICA_DATABASE_URL}
    volumes:
      - ./config:/app/config:ro
    depends_on:
      - pg-change-stream

volumes:
  redis-data:
```

### Step 3: Transforms Configuration

Create a `config` directory and add `transforms.yml`:

```bash
mkdir config
```

Create `config/transforms.yml` with your transformation rules:

```yaml
version: v1
tables:
  # Example: Transform user emails in the public.users table
  public.users:
    email: FakeEmail
    phone: FakePhone
```

See the [Transform Configuration](/configuration/transforms) guide for all available transforms.

### Step 4: Environment Variables

Create a `.env` file with your database connections and service configuration:

```bash
# Source database (read-only access needed)
PRIMARY_DATABASE_URL=postgresql://kasho:password@source-host:5432/source_db?sslmode=disable

# Target database (write access needed)
REPLICA_DATABASE_URL=postgresql://kasho:password@target-host:5432/target_db?sslmode=disable

# Redis connection for pg-change-stream
KV_URL=redis://redis:6379

# Change stream service for pg-translicator
CHANGE_STREAM_SERVICE_ADDR=pg-change-stream:50051

# License service address (optional)
LICENSING_SERVICE_ADDR=license-service:8090
```

<div className="alert alert-info mb-4">
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" className="stroke-current shrink-0 w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
  <div>
    <div className="font-semibold">Production Note</div>
    <div>In production, these service URLs will depend on your infrastructure. For example, in Kubernetes you might use service names like `redis.default.svc.cluster.local:6379`.</div>
  </div>
</div>

### Step 5: Run the Example

```bash
docker-compose up -d
```

Verify all services are running:

```bash
docker-compose ps
```

You should see:
- `redis` - Running
- `pg-change-stream` - Running on port 50051
- `pg-translicator` - Running

## Production Considerations

When deploying to production:

1. **Container Orchestration**: Translate the Docker Compose configuration to your platform:
   - Kubernetes: Create Deployments, Services, and ConfigMaps
   - ECS: Define Task Definitions and Services
   - Other platforms: Follow your standard container deployment practices

2. **Redis**: Use a managed Redis service or ensure high availability

3. **Networking**: Ensure containers can communicate:
   - `pg-translicator` must reach `pg-change-stream` service
   - Both services need access to their respective databases
   - Consider service discovery mechanisms in your environment

4. **Configuration Management**: Mount transform configurations using your platform's methods:
   - Kubernetes: ConfigMaps or Secrets
   - ECS: Parameter Store or S3
   - Docker: Volume mounts or config management tools

## Bootstrap Existing Data

If you have existing data in your source database, you'll need to run the bootstrap process:

<div className="alert alert-info mb-4">
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" className="stroke-current shrink-0 w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
  <span>The bootstrap process ensures zero data loss by capturing changes during the initial data load</span>
</div>

1. Execute the bootstrap process in the pg-change-stream container:

```bash
# Run bootstrap process (will prompt for confirmation)
docker exec -it kasho-example-pg-change-stream-1 ./bootstrap-kasho.sh
```

<div className="alert alert-info mb-4">
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" className="stroke-current shrink-0 w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
  <div>
    <div className="font-semibold">Container Name</div>
    <div>The container name may vary based on your setup. Use `docker ps` to find the exact name of your pg-change-stream container.</div>
  </div>
</div>

2. The bootstrap process will:
   - Create a consistent snapshot of your source database
   - Start capturing changes from that point
   - Load the snapshot data
   - Transition to streaming mode

If you prefer, you can manually bootstrap things with a bit more effort. See the [Bootstrap Process](/installation/bootstrap) guide for detailed information.

## Verify Installation

Check that replication is working:

1. **Check `pg-change-stream` status (using gRPC):**
   ```bash
   # Using grpcurl (install with: brew install grpcurl)
   grpcurl -plaintext localhost:50051 kasho.ChangeStreamService/GetStatus
   ```

2. **View logs:**
   ```bash
   docker-compose logs -f pg-change-stream
   docker-compose logs -f pg-translicator
   ```

3. **Make a test change in your source database:**
   ```sql
   -- In your source database
   UPDATE users SET updated_at = NOW() WHERE id = 1;
   ```

4. **Verify the change appears in your target database**

## Next Steps

- [Configure your databases](/installation/database-setup) for production use
- [Understand configuration options](/installation/configuration)
- [Learn about transforms](/configuration/transforms)

## Troubleshooting

**Services won't start:**
- Ensure your environment variables are set correctly, especially the database URLs.
- Verify `transforms.yml` exists in the config directory
- Check logs: `docker-compose logs [service-name]`

**Connection errors:**
- Ensure databases are accessible from Docker containers
- Verify PostgreSQL has `wal_level = logical`
- Check firewall rules allow connections