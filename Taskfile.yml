version: "3"

vars:
  SERVICES:
    sh: find services -maxdepth 2 -name go.mod -exec dirname {} \; | sort
  TOOLS:
    sh: find tools -maxdepth 3 -name go.mod -exec dirname {} \; | sort
  PACKAGES:
    sh: find pkg -maxdepth 2 -name go.mod -exec dirname {} \; | sort
  APPS:
    sh: find apps -maxdepth 2 -name package.json -exec dirname {} \; | grep -v node_modules | sort
  # Version information
  GIT_TAG:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "v0.0.0"
  VERSION:
    sh: echo "{{.GIT_TAG}}" | sed 's/^v//' # Strip v prefix for semver compliance
  COMMIT:
    sh: git rev-parse HEAD 2>/dev/null || echo "unknown"
  DATE:
    sh: date -u +"%Y-%m-%dT%H:%M:%SZ"
  LDFLAGS: >-
    -X kasho/pkg/version.Version={{.VERSION}}
    -X kasho/pkg/version.GitCommit={{.COMMIT}}
    -X kasho/pkg/version.BuildDate={{.DATE}}

tasks:
  default:
    desc: List all available tasks
    cmds:
      - task --list

  build:
    desc: Build the kasho Docker image for development
    deps: [build:base]
    cmds:
      - docker build -t kasho --target development --build-arg LDFLAGS="-X kasho/pkg/version.Version=dev -X kasho/pkg/version.GitCommit=dev -X kasho/pkg/version.BuildDate=dev" .
    # NOTE: Keep these sources in sync with .github/workflows/publish-containers.yml
    # The publish-containers workflow uses the same list to determine when to rebuild containers
    sources:
      - Dockerfile
      - Taskfile.yml
      - go.work
      - go.work.sum
      - "**/*.go"
      - "!**/*_test.go"
      - scripts/runtime/**/*.sh
      - environments/development/.air.toml
      - proto/**

  build:base:
    desc: Build the base image with cached dependencies
    cmds:
      - docker build -f Dockerfile.base -t kasho-base .
    sources:
      - Dockerfile.base
      - Taskfile.yml
      - go.work
      - "**/go.mod"

  proto:
    desc: Generate Go code from protobuf definitions
    cmds:
      - protoc --go_out=proto/kasho --go_opt=paths=source_relative --go-grpc_out=proto/kasho --go-grpc_opt=paths=source_relative proto/change_stream.proto
      - protoc --go_out=proto/kasho --go_opt=paths=source_relative --go-grpc_out=proto/kasho --go-grpc_opt=paths=source_relative proto/license.proto

  test:
    desc: Run all tests (Go services + Next.js apps)
    cmds:
      - task: test:go
      - task: test:apps
      - echo "‚úÖ All tests passed!"

  test:go:
    desc: Run tests for all Go services and packages
    cmds:
      - |
        dirs="{{.SERVICES}} {{.TOOLS}} {{.PACKAGES}} proto/kasho/proto"
        failed=0
        for dir in $dirs; do
          echo "üß™ Testing $(basename $dir)..."
          if [ -n "$(find "$dir" -name '*_test.go' -print -quit)" ]; then
            if ! (cd "$dir" && go test -v -race -coverprofile=coverage.out ./... && go tool cover -func=coverage.out); then
              failed=1
            fi
          else
            echo "  ‚è≠Ô∏è  No test files found, skipping..."
          fi
        done
        exit $failed

  test:apps:
    desc: Run tests for all Next.js apps
    cmds:
      - |
        dirs="{{.APPS}}"
        failed=0
        for dir in $dirs; do
          echo "üß™ Testing $(basename $dir) app..."
          if ! (cd "$dir" && npm run test); then
            failed=1
          fi
        done
        exit $failed

  # Individual component testing (for convenience)
  test:service:*:
    desc: Run tests for a specific service
    cmds:
      - echo "üß™ Testing {{index .MATCH 0}} service..."
      - |
        cd services/{{index .MATCH 0}}
        if [ -n "$(find . -name '*_test.go' -print -quit)" ]; then
          go test -v -race -coverprofile=coverage.out ./...
          go tool cover -func=coverage.out
        else
          echo "  ‚è≠Ô∏è  No test files found"
        fi

  test:tool:*:
    desc: Run tests for a specific tool
    cmds:
      - echo "üß™ Testing {{index .MATCH 0}} tool..."
      - |
        cd tools/{{index .MATCH 0}}
        if [ -n "$(find . -name '*_test.go' -print -quit)" ]; then
          go test -v -race -coverprofile=coverage.out ./...
          go tool cover -func=coverage.out
        else
          echo "  ‚è≠Ô∏è  No test files found"
        fi

  test:pkg:*:
    desc: Run tests for a specific package
    cmds:
      - echo "üß™ Testing {{index .MATCH 0}} package..."
      - |
        cd pkg/{{index .MATCH 0}}
        if [ -n "$(find . -name '*_test.go' -print -quit)" ]; then
          go test -v -race -coverprofile=coverage.out ./...
          go tool cover -func=coverage.out
        else
          echo "  ‚è≠Ô∏è  No test files found"
        fi

  test:app:*:
    desc: Run tests for a specific app
    cmds:
      - echo "üß™ Testing {{index .MATCH 0}} app..."
      - npm run test --workspace=apps/{{index .MATCH 0}}

  dev:
    desc: Start development environment (alias for dev:start)
    deps: [dev:start]

  dev:start:
    desc: Start development environment
    deps: [build]
    cmds:
      - cd environments/development && docker-compose up

  dev:stop:
    desc: Stop development environment and remove volumes
    cmds:
      - cd environments/development && docker-compose down -v

  dev:reset:
    desc: Reset and restart development environment (removes volumes)
    deps: [dev:stop, dev:start]

  dev:bootstrap:
    desc: Bootstrap from a pg_dump, then start streaming changes
    cmds:
      - cd environments/development && docker-compose exec -e WAIT_FOR_BOOTSTRAP=true pg-change-stream /app/scripts/bootstrap-kasho.sh

  dev:app:*:
    desc: Start a specific app in development mode
    deps: [apps:deps:install]
    cmds:
      - |
        app="{{index .MATCH 0}}"
        case "$app" in
          homepage) port="${APP_HOMEPAGE_PORT:-3000}" ;;
          demo) port="${APP_DEMO_PORT:-3001}" ;;
          docs) port="${APP_DOCS_PORT:-3002}" ;;
          *) port=3000 ;;
        esac
        npm run dev --workspace=apps/$app -- --port $port

  # Lint tasks
  lint:
    desc: Run linting for all code
    cmds:
      - task: lint:go
      - task: lint:apps

  lint:go:
    desc: Run linting for Go services and packages
    cmds:
      - |
        dirs="{{.SERVICES}} {{.TOOLS}} {{.PACKAGES}} proto/kasho/proto"
        for dir in $dirs; do
          echo "üîç Linting $(basename $dir)..."
          (cd "$dir" && go vet ./...)
        done

  lint:apps:
    desc: Run linting for Next.js apps
    cmds:
      - |
        dirs="{{.APPS}}"
        for dir in $dirs; do
          echo "üîç Linting $(basename $dir) app..."
          (cd "$dir" && npm run lint)
        done

  lint:app:*:
    desc: Lint a specific app
    cmds:
      - echo "üîç Linting {{index .MATCH 0}} app..."
      - npm run lint --workspace=apps/{{index .MATCH 0}}

  # Prettier tasks
  apps:prettier:
    desc: Run prettier for all frontend applications
    cmds:
      - echo "üé® Formatting all apps..."
      - npx prettier --write "apps/**/*.{ts,tsx,js,jsx,json,md}"

  apps:prettier:check:
    desc: Check prettier formatting for all frontend applications (without writing)
    cmds:
      - echo "üîç Checking prettier formatting for all apps..."
      - npx prettier --check "apps/**/*.{ts,tsx,js,jsx,json,md}"

  apps:prettier:*:
    desc: Run prettier for a specific app
    cmds:
      - |
        app="{{index .MATCH 0}}"
        if [ -d "apps/$app" ]; then
          echo "üé® Formatting $app app..."
          npm run prettier --workspace=apps/$app
        else
          echo "‚ùå App '$app' not found in apps/ directory"
          exit 1
        fi

  # Workspace management tasks
  apps:deps:install:
    desc: Install dependencies for all apps using workspace
    cmds:
      - npm install

  apps:deps:update:
    desc: Update dependencies for all apps
    cmds:
      - npm update --workspaces

  apps:deps:clean:
    desc: Clean node_modules for all apps
    cmds:
      - rm -rf node_modules apps/*/node_modules

  apps:lockfiles:clean:
    desc: Remove individual app package-lock.json files (workspace manages locking)
    cmds:
      - rm -f apps/*/package-lock.json

  # Version tasks
  version:
    desc: Display version information
    cmds:
      - "echo Version: {{.VERSION}}"
      - "echo Commit: {{.COMMIT}}"
      - "echo Build Date: {{.DATE}}"
